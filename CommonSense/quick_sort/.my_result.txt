前提: int  test1[] = {0, 5, 2, 1, 6, 3}



------------------
(1回目の表示結果)


	left: 0
	right: 5
	0 5 2 1 6 3 


---------------------
(次に期待される流れの説明)

partition(test1, 0, 5)が1回呼ばれて，test1[]は

0 1 2 3 6 5

になる(3 が適切な pivot の位置に移動している)。
partition の 返り値は left なので，今回は 3

....

partition が呼ばれた後，
quick_sortを再帰的に２回呼び出す。まずは一回目。1回目の呼び出しは

quick_sort(test1[], left, partionの返り値 - 1)

なので，

quick_sort({0, 5, 2, 1, 6, 3}, 0, 2);

と渡されることが期待される。

------------------

	left: 0
	right: 2
	0 1 2 3 6 5 


上で説明した，期待される通りの表示になっている。
もう一度 partiton が 

partiton(test1, 0, 2);

で呼ばれるが，2 は {0, 1, 2}という部分配列の中で適切な pivot の位置にあるため
配列はそのままにして，返り値として left の値を返す。
今回は, left が {0, 1, 2}の左端になるので， 返り値は 2 である。

再度 quick_sortが呼ばれて，

quick_sort({0, 1, 2, 3, 6, 5}, 0, 2 - 1);

となる。

------------------

	left: 0
	right: 1
	0 1 2 3 6 5 



-----------------
	left: 0
	right: 0
	0 1 2 3 6 5 


-----------------
left: 2
right: 1
0 1 2 3 6 5 
left: 2
right: 1
0 2 1 3 6 5 
left: 2
right: 2
0 3 1 2 6 5 
left: 4
right: 1
0 3 1 2 6 5 
left: 4
right: 3
0 6 1 2 3 5 
left: 4
right: 3
0 6 1 3 2 5 
left: 4
right: 4
0 6 1 5 2 3 
left: 6
right: 3
0 6 1 5 2 3
